import 'package:dicionario_waiwai/models/meaning.dart';
import 'package:dicionario_waiwai/models/reference.dart';
import 'package:dicionario_waiwai/models/user.dart';
import 'package:dicionario_waiwai/models/word.dart';

import 'package:drift/drift.dart';
import 'connection/connection.dart' as impl;

// // Manually generated by `drift_dev schema steps` - this file makes writing
// // migrations easier. See this for details:
// // https://drift.simonbinder.eu/docs/advanced-features/migrations/#step-by-step
// dart run drift_dev schema steps .\lib\database\database.dart .\lib\database\schema_versions.dart
// import 'schema_versions.dart';

// // Generated by drift_dev when running `build_runner build`
// dart run drift_dev schema dump lib/database/database.dart drift_schemas/
// dart run drift_dev schema generate drift_schemas/ test/generated_migrations/
// dart run drift_dev schema steps drift_schemas/ lib/database/schema_versions.dart

// dart run build_runner build
part 'database.g.dart';

@DriftDatabase(
  tables: [
    User,
    Reference,
    Word,
    Meaning,
  ],
// include: {
//   'sql.drift'} // https://drift.simonbinder.eu/docs/sql-api/
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(impl.connect());

  AppDatabase.forTesting(DatabaseConnection connection) : super(connection);

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      //   onUpgrade: stepByStep(
      //     from1To2: (m, schema) async {
      //       // The todoEntries.dueDate column was added in version 2.
      //       await m.drop(user);
      //       await m.drop(reference);
      //       await m.drop(word);
      //       await m.drop(meaning);
      //       await m.createAll();
      //     },
      //   from2To3: (m, schema) async {
      //     // New triggers were added in version 3:
      //     await m.create(schema.todosDelete);
      //     await m.create(schema.todosUpdate);

      //     // Also, the `REFERENCES` constraint was added to
      //     // [TodoEntries.category]. Run a table migration to rebuild all
      //     // column constraints without loosing data.
      //     await m.alterTable(TableMigration(schema.todoEntries));
      //   },
      //   ),
      beforeOpen: (details) async {
        // Make sure that foreign keys are enabled
        await customStatement('PRAGMA foreign_keys = ON');
        if (details.wasCreated) {
          // Create a bunch of default values so the app doesn't look too empty
          // on the first start.
          //   await batch((b) {
          //     b.insert(
          //       categories,
          //       CategoriesCompanion.insert(name: 'Important', color: Colors.red),
          //     );

          //     b.insertAll(todoEntries, [
          //       TodoEntriesCompanion.insert(description: 'Check out drift'),
          //       TodoEntriesCompanion.insert(
          //           description: 'Fix session invalidation bug',
          //           category: const Value(1)),
          //       TodoEntriesCompanion.insert(
          //           description: 'Add favorite movies to home page'),
          //     ]);
          //   });
        }

        // This follows the recommendation to validate that the database schema
        // matches what drift expects (https://drift.simonbinder.eu/docs/advanced-features/migrations/#verifying-a-database-schema-at-runtime).
        // It allows catching bugs in the migration logic early.
        await impl.validateDatabaseSchema(this);
      },
    );
  }

  Future<void> insertMany(
      List<UserCompanion> userlist,
      List<ReferenceCompanion> referencelist,
      List<WordCompanion> wordlist,
      List<MeaningCompanion> meaninglist) async {
    await batch((batch) {
      batch.deleteAll(meaning);
      batch.deleteAll(word);
      batch.deleteAll(reference);
      batch.deleteAll(user);
      batch.insertAll(user, userlist);
      batch.insertAll(reference, referencelist);
      batch.insertAll(word, wordlist);
      batch.insertAll(meaning, meaninglist);
    });
  }
}

typedef MeaningWithReference = (Meaning meaning, Reference reference);

typedef WordWithMeaning = (Word word, MeaningWithReference meanings);

abstract class Repository<R, C> {
  Future<void> insert(C item);
  Stream<R> getById(int id);
  // Stream<List<R>> listByPage({int page = 1, int size = 50});
//   Stream<void> listByPage({int page = 1, int size = 50});
  Future<void> update(C item);
  Future<void> delete(int id);
  Future<void> insertMany(List<C> list);
}

class WordRepository extends Repository<Word, WordCompanion> {
  final AppDatabase _database;

  WordRepository(this._database);

  @override
  Future<void> insert(WordCompanion item) {
    throw UnimplementedError();
  }

  @override
  Stream<Word> getById(int id) {
    throw UnimplementedError();
  }

  Stream<List<WordWithMeaning>> listByPage({int page = 1, int size = 50}) {
    int offset = (page - 1) * size;
    int limit = size;

    final wordWithLimit = Subquery(
      _database.select(_database.word)
        ..orderBy([(row) => OrderingTerm.asc(row.word)])
        ..limit(limit, offset: offset),
      's',
    );

    final query = _database.select(wordWithLimit).join([
      innerJoin(
          _database.meaning,
          wordWithLimit
              .ref(_database.word.id)
              .equalsExp(_database.meaning.wordId)),
      innerJoin(_database.reference,
          _database.meaning.referenceId.equalsExp(_database.reference.id))
    ]);

    return query.watch().map((rows) {
      return rows.map((row) {
        return (
          row.readTable(wordWithLimit),
          (row.readTable(_database.meaning), row.readTable(_database.reference))
        );
      }).toList();
    });

    // return query.watch().map(
    //   (rows) {
    //     return ((row) => );
    //     return (
    //       row.readTable(wordWithLimit),
    //       (row.readTable(_database.meaning), row.readTable(_database.reference))
    //     );
    //   },
    // );
  }

  @override
  Future<void> update(WordCompanion item) {
    throw UnimplementedError();
  }

  @override
  Future<void> delete(int id) {
    throw UnimplementedError();
  }

  @override
  Future<void> insertMany(List<WordCompanion> list) async {
    await _database.batch((batch) {
      batch.insertAll(_database.word, list);
    });
  }
}

class UserRepository extends Repository<User, UserCompanion> {
  final AppDatabase _database;

  UserRepository(this._database);

  @override
  Future<void> insert(UserCompanion item) {
    throw UnimplementedError();
  }

  @override
  Stream<User> getById(int id) {
    throw UnimplementedError();
  }

  Stream<void> listByPage({int page = 1, int size = 50}) {
    throw UnimplementedError();
  }

  @override
  Future<void> update(UserCompanion item) {
    throw UnimplementedError();
  }

  @override
  Future<void> delete(int id) {
    throw UnimplementedError();
  }

  @override
  Future<void> insertMany(List<UserCompanion> list) async {
    await _database.batch((batch) {
      batch.insertAll(_database.user, list);
    });
  }
}

class ReferenceRepository extends Repository<Reference, ReferenceCompanion> {
  final AppDatabase _database;

  ReferenceRepository(this._database);

  @override
  Future<void> insert(ReferenceCompanion item) {
    throw UnimplementedError();
  }

  @override
  Stream<Reference> getById(int id) {
    throw UnimplementedError();
  }

  Stream<void> listByPage({int page = 1, int size = 50}) {
    throw UnimplementedError();
  }

  @override
  Future<void> update(ReferenceCompanion item) {
    throw UnimplementedError();
  }

  @override
  Future<void> delete(int id) {
    throw UnimplementedError();
  }

  @override
  Future<void> insertMany(List<ReferenceCompanion> list) async {
    await _database.batch((batch) {
      batch.insertAll(_database.reference, list);
    });
  }
}

class MeaningRepository extends Repository<Meaning, MeaningCompanion> {
  final AppDatabase _database;

  MeaningRepository(this._database);

  @override
  Future<void> insert(MeaningCompanion item) {
    throw UnimplementedError();
  }

  @override
  Stream<Meaning> getById(int id) {
    throw UnimplementedError();
  }

  Stream<void> listByPage({int page = 1, int size = 50}) {
    throw UnimplementedError();
  }

  @override
  Future<void> update(MeaningCompanion item) {
    throw UnimplementedError();
  }

  @override
  Future<void> delete(int id) {
    throw UnimplementedError();
  }

  @override
  Future<void> insertMany(List<MeaningCompanion> list) async {
    await _database.batch((batch) {
      batch.insertAll(_database.meaning, list);
    });
  }
}
