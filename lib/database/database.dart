// import 'dart:js_interop';

import 'package:drift/drift.dart';
import 'connection/connection.dart' as impl;
import 'dart:developer';

// dart run drift_dev schema steps .\lib\database\database.dart .\lib\database\schema_versions.dart
// import 'schema_versions.dart';

// // Generated by drift_dev when running `build_runner build`
// dart run drift_dev schema dump lib/database/database.dart drift_schemas/
// dart run drift_dev schema generate drift_schemas/ test/generated_migrations/
// dart run drift_dev schema steps drift_schemas/ lib/database/schema_versions.dart

// dart run build_runner build

part 'database.g.dart';

mixin BaseTable on Table {
  IntColumn get id => integer()();
  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('Reference')
class References extends Table with BaseTable {
  TextColumn get reference => text()();
  IntColumn get year => integer()();
  TextColumn get authors => text()();
  TextColumn get url => text().nullable()();
}

@DataClassName('Category')
class Categories extends Table with BaseTable {
  TextColumn get category => text()();
  TextColumn get description => text()();
}

@DataClassName('User')
class Users extends Table with BaseTable {
  TextColumn get fullName => text().named('full_name')();
}

@DataClassName('Word')
class Words extends Table with BaseTable {
  TextColumn get word => text()();
  TextColumn get phonemic => text().nullable()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();

  IntColumn get userId => integer().references(Users, #id)();
}

@DataClassName('Meaning')
class Meanings extends Table with BaseTable {
  TextColumn get meaningPt => text()();
  TextColumn get meaningWw => text().nullable()();
  TextColumn get commentPt => text().nullable()();
  TextColumn get commentWw => text().nullable()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();

  IntColumn get wordId => integer().references(Words, #id)();
  IntColumn get referenceId => integer().references(References, #id)();
  IntColumn get userId => integer().references(Users, #id)();
}

@DataClassName('Attachment')
class Attachments extends Table with BaseTable {
  TextColumn get uuid => text()();
  TextColumn get fileName => text()();
  TextColumn get fileDir => text()();
  TextColumn get url => text()();
  TextColumn get contentType => text()();

  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updatedAt => dateTime()();

  IntColumn get wordId => integer().references(Words, #id)();
  IntColumn get userId => integer().references(Users, #id)();
}

@DataClassName('WordCategory')
class WordCategories extends Table {
  IntColumn get wordId => integer().references(Words, #id)();
  IntColumn get categoryId => integer().references(Categories, #id)();
}

@DriftDatabase(
  tables: [
    References,
    Categories,
    Users,
    Words,
    Meanings,
    Attachments,
    WordCategories
  ],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(impl.connect());

  AppDatabase.forTesting(DatabaseConnection super.connection);

  @override
  int get schemaVersion => 3;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        if (from < 2) {
          await m.deleteTable('Meanings');
          await m.deleteTable('Attachments');
          await m.deleteTable('WordCategories');
          await m.deleteTable('Words');
          await m.deleteTable('References');
          await m.deleteTable('Categories');
          await m.deleteTable('Users');
          await m.createAll();

          // we added the dueDate property in the change from version 1 to
          // version 2
          // await m.addColumn(todos, todos.dueDate);
        }
        if (from < 3) {
          // we added the priority property in the change from version 1 or 2
          // to version 3
          await m.deleteTable('Meanings');
          await m.deleteTable('Attachments');
          await m.deleteTable('WordCategories');
          await m.deleteTable('Words');
          await m.deleteTable('References');
          await m.deleteTable('Categories');
          await m.deleteTable('Users');
          await m.createAll();
        }
      },
      beforeOpen: (details) async {
        if (details.wasCreated) {}

        await impl.validateDatabaseSchema(this);
      },
    );
  }

  Future<void> insertMany(
      List<UsersCompanion> userlist,
      List<ReferencesCompanion> referencelist,
      List<WordsCompanion> wordlist,
      List<MeaningsCompanion> meaninglist,
      List<CategoriesCompanion> categorylist,
      List<WordCategoriesCompanion> wordcategorylist,
      List<AttachmentsCompanion> attachmentlist) async {
    await batch((batch) {
      batch.deleteAll(meanings);
      batch.deleteAll(attachments);
      batch.deleteAll(wordCategories);
      batch.deleteAll(words);
      batch.deleteAll(references);
      batch.deleteAll(categories);
      batch.deleteAll(users);

      batch.insertAll(users, userlist);
      batch.insertAll(categories, categorylist);
      batch.insertAll(references, referencelist);
      batch.insertAll(words, wordlist);
      batch.insertAll(wordCategories, wordcategorylist);
      batch.insertAll(attachments, attachmentlist);
      batch.insertAll(meanings, meaninglist);
    });
  }
}

abstract class Repository<R, C, L> {
  Future<void> insert(C item);
  Future<void> insertMany(List<C> list);
  Future<L> getByPage({int page = 1, int size = 50});
  Stream<R> getById(int id);
  Future<void> update(C item);
  Future<void> deleteById(int id);
}

typedef MeaningWithReference = (Meaning meaning, Reference reference);

typedef WordWithMeaning = (Word word, List<MeaningWithReference> meanings);

typedef WordList = List<WordWithMeaning>;

typedef Criteria = (String search, int category);

class WordRepository extends Repository<Words, WordsCompanion, WordList> {
  final AppDatabase _database;
  WordRepository(this._database);

  @override
  Future<void> deleteById(int id) {
    // TODO: implement deleteById
    throw UnimplementedError();
  }

  @override
  Stream<Words> getById(int id) {
    // TODO: implement getById
    throw UnimplementedError();
  }

  @override
  Future<WordList> getByPage(
      {Criteria criteria = ('', 1), int page = 1, int size = 50}) async {
    int offset = (page - 1) * size;
    int limit = size;

    String search = criteria.$1;
    int category = criteria.$2;

    final idsOfWords = _database.words.id;

    JoinedSelectStatement wordWithLimitQuery =
        _database.selectOnly(_database.words).join([
      innerJoin(_database.meanings,
          _database.meanings.wordId.equalsExp(_database.words.id),
          useColumns: false),
      innerJoin(_database.wordCategories,
          _database.wordCategories.wordId.equalsExp(_database.words.id),
          useColumns: false),
      innerJoin(
          _database.categories,
          _database.wordCategories.categoryId
              .equalsExp(_database.categories.id),
          useColumns: false),
    ])
          ..orderBy([
            OrderingTerm.asc(_database.words.word),
            OrderingTerm.desc(_database.words.word.length)
          ])
          ..groupBy([_database.words.id])
          ..limit(limit, offset: offset);
    if (category > 1) {
      wordWithLimitQuery.where(_database.categories.id.equals(category));
    }
    if (search.isNotEmpty) {
      wordWithLimitQuery.where(_database.words.word.upper().like('%$search%') |
          _database.meanings.meaningPt.upper().like('%$search%'));
    }

    wordWithLimitQuery.addColumns([idsOfWords]);

    final wordWithLimitSubquery = Subquery(
      wordWithLimitQuery,
      's',
    );

    final query = _database.select(wordWithLimitSubquery).join([
      innerJoin(
          _database.meanings,
          wordWithLimitSubquery
              .ref(_database.words.id)
              .equalsExp(_database.meanings.wordId)),
      innerJoin(
          _database.words,
          wordWithLimitSubquery
              .ref(_database.words.id)
              .equalsExp(_database.words.id)),
      innerJoin(_database.references,
          _database.meanings.referenceId.equalsExp(_database.references.id))
    ]);

    final result = await query.get().then((rows) {
      WordList wordList = [];
      for (var row in rows) {
        final condition = wordList.where(
            (element) => element.$1.id == row.readTable(_database.words).id);
        if (condition.isEmpty) {
          wordList.add((
            row.readTable(_database.words),
            [
              (
                row.readTable(_database.meanings),
                row.readTable(_database.references)
              )
            ]
          ));
        } else {
          condition.first.$2.add((
            row.readTable(_database.meanings),
            row.readTable(_database.references)
          ));
        }
      }
      return wordList;
    });
    return result;
  }

  @override
  Future<void> insert(WordsCompanion item) {
    // TODO: implement insert
    throw UnimplementedError();
  }

  @override
  Future<void> insertMany(List<WordsCompanion> list) {
    // TODO: implement insertMany
    throw UnimplementedError();
  }

  @override
  Future<void> update(WordsCompanion item) {
    // TODO: implement update
    throw UnimplementedError();
  }

  Future<CategoryList> getAllCategories() async {
    final query = _database.select(_database.categories)
      ..orderBy([(categories) => OrderingTerm.asc(categories.id)]);
    final result = await query.get();
    return result;
  }

  Future<int> count({String criteria = ''}) async {
    final wordSubquery = Subquery(
      _database.select(_database.words),
      's',
    );

    final amountOfWords =
        wordSubquery.ref(_database.words.id).count(distinct: true);

    JoinedSelectStatement query = _database.select(wordSubquery).join([
      innerJoin(
          _database.meanings,
          wordSubquery
              .ref(_database.words.id)
              .equalsExp(_database.meanings.wordId),
          useColumns: false)
    ])
      ..addColumns([amountOfWords]);
    // ..groupBy([wordSubquery.ref(_database.words.id)]);

    if (criteria.isNotEmpty) {
      query = query
        ..where(wordSubquery.ref(_database.words.word).like('%$criteria%') |
            _database.meanings.meaningPt.like('%$criteria%'));
    }

    final result = await query.getSingle();
    final wordCount = result.read(amountOfWords);
    return wordCount ?? 0;
  }

//   final AppDatabase _database;

//   WordRepository(this._database);

//   @override
//   Future<void> insert(WordsCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<void> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<List<WordWithMeaning>> listByPage({int page = 1, int size = 50}) {
//     int offset = (page - 1) * size;
//     int limit = size;

//     final wordWithLimit = Subquery(
//       _database.select(_database.word)
//         ..orderBy([(row) => OrderingTerm.asc(row.word)])
//         ..limit(limit, offset: offset),
//       's',
//     );

//     final query = _database.select(wordWithLimit).join([
//       innerJoin(
//           _database.meaning,
//           wordWithLimit
//               .ref(_database.word.id)
//               .equalsExp(_database.meaning.wordId)),
//       innerJoin(_database.reference,
//           _database.meaning.referenceId.equalsExp(_database.reference.id))
//     ]);

//     return query.watch().map((rows) {
//       return rows.map((row) {
//         return (
//           row.readTable(wordWithLimit),
//           (row.readTable(_database.meaning), row.readTable(_database.reference))
//         );
//       }).toList();
//     });
//   }

//   @override
//   Future<void> update(WordCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<WordCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.word, list);
//     });
//   }
}

typedef CategoryList = List<Category>;


// class UserRepository extends Repository<User, UserCompanion> {
//   final AppDatabase _database;

//   UserRepository(this._database);

//   @override
//   Future<void> insert(UserCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<User> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<void> listByPage({int page = 1, int size = 50}) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> update(UserCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<UserCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.user, list);
//     });
//   }
// }

// class ReferenceRepository extends Repository<Reference, ReferenceCompanion> {
//   final AppDatabase _database;

//   ReferenceRepository(this._database);

//   @override
//   Future<void> insert(ReferenceCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<Reference> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<void> listByPage({int page = 1, int size = 50}) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> update(ReferenceCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<ReferenceCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.reference, list);
//     });
//   }
// }

// class MeaningRepository extends Repository<Meaning, MeaningCompanion> {
//   final AppDatabase _database;

//   MeaningRepository(this._database);

//   @override
//   Future<void> insert(MeaningCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<Meaning> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<void> listByPage({int page = 1, int size = 50}) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> update(MeaningCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<MeaningCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.meaning, list);
//     });
//   }
// }
