// import 'dart:js_interop';

import 'package:drift/drift.dart';
import 'connection/connection.dart' as impl;

// dart run drift_dev schema steps .\lib\database\database.dart .\lib\database\schema_versions.dart
// import 'schema_versions.dart';

// // Generated by drift_dev when running `build_runner build`
// dart run drift_dev schema dump lib/database/database.dart drift_schemas/
// dart run drift_dev schema generate drift_schemas/ test/generated_migrations/
// dart run drift_dev schema steps drift_schemas/ lib/database/schema_versions.dart

// dart run build_runner build

part 'database.g.dart';

mixin BaseTable on Table {
  IntColumn get id => integer()();
  @override
  Set<Column> get primaryKey => {id};
}

@DataClassName('Reference')
class References extends Table with BaseTable {
  TextColumn get reference => text()();
  TextColumn get url => text().nullable()();
}

@DataClassName('User')
class Users extends Table with BaseTable {
  TextColumn get fullName => text().named('full_name')();
}

@DataClassName('Word')
class Words extends Table with BaseTable {
  TextColumn get word => text()();
  TextColumn get phonemic => text().nullable()();
  DateTimeColumn get createdAt => dateTime()();
  DateTimeColumn get updateAt => dateTime()();
  IntColumn get userId => integer().references(Users, #id)();
}

@DataClassName('Meaning')
class Meanings extends Table with BaseTable {
  TextColumn get meaning => text()();
  TextColumn get comment => text().nullable()();
  IntColumn get chapterId => integer().nullable()();
  IntColumn get entryId => integer().nullable()();
  IntColumn get wordId => integer().references(Words, #id)();
  IntColumn get referenceId => integer().references(References, #id)();
  IntColumn get userId => integer().references(Users, #id)();
}

@DriftDatabase(
  tables: [
    Users,
    References,
    Words,
    Meanings,
  ],
)
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(impl.connect());

  AppDatabase.forTesting(DatabaseConnection super.connection);

  @override
  int get schemaVersion => 1;

  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
      },
      beforeOpen: (details) async {
        if (details.wasCreated) {}

        await impl.validateDatabaseSchema(this);
      },
    );
  }

  Future<void> insertMany(
      List<UsersCompanion> userlist,
      List<ReferencesCompanion> referencelist,
      List<WordsCompanion> wordlist,
      List<MeaningsCompanion> meaninglist) async {
    await batch((batch) {
      batch.deleteAll(meanings);
      batch.deleteAll(words);
      batch.deleteAll(references);
      batch.deleteAll(users);
      batch.insertAll(users, userlist);
      batch.insertAll(references, referencelist);
      batch.insertAll(words, wordlist);
      batch.insertAll(meanings, meaninglist);
    });
  }
}

abstract class Repository<R, C, L> {
  Future<void> insert(C item);
  Future<void> insertMany(List<C> list);
  Future<L> getByPage({int page = 1, int size = 50});
  Stream<R> getById(int id);
  Future<void> update(C item);
  Future<void> deleteById(int id);
}

typedef MeaningWithReference = (Meaning meaning, Reference reference);

typedef WordWithMeaning = (Word word, List<MeaningWithReference> meanings);

typedef WordList = List<WordWithMeaning>;

class WordRepository extends Repository<Words, WordsCompanion, WordList> {
  final AppDatabase _database;
  WordRepository(this._database);

  @override
  Future<void> deleteById(int id) {
    // TODO: implement deleteById
    throw UnimplementedError();
  }

  @override
  Stream<Words> getById(int id) {
    // TODO: implement getById
    throw UnimplementedError();
  }

  @override
  Future<WordList> getByPage(
      {String criteria = '', int page = 1, int size = 50}) async {
    int offset = (page - 1) * size;
    int limit = size;

    final wordWithLimitQuery = _database.select(_database.words)
      ..limit(limit, offset: offset);

    final wordWithLimitSubquery = Subquery(
      wordWithLimitQuery,
      's',
    );
    JoinedSelectStatement query = _database.select(wordWithLimitSubquery).join([
      innerJoin(
          _database.meanings,
          wordWithLimitSubquery
              .ref(_database.words.id)
              .equalsExp(_database.meanings.wordId)),
      innerJoin(_database.references,
          _database.meanings.referenceId.equalsExp(_database.references.id))
    ])
      ..orderBy([
        OrderingTerm.asc(wordWithLimitSubquery.ref(_database.words.word)),
        OrderingTerm.desc(
            wordWithLimitSubquery.ref(_database.words.word).length)
      ]);

    if (criteria.isNotEmpty) {
      query = query
        ..where(wordWithLimitSubquery
                .ref(_database.words.word)
                .like('%$criteria%') |
            _database.meanings.meaning.like('%$criteria%'));
    }

    final result = await query.get().then((rows) {
      WordList wordList = [];
      for (var row in rows) {
        final condition = wordList.where((element) =>
            element.$1.id == row.readTable(wordWithLimitSubquery).id);
        if (condition.isEmpty) {
          wordList.add((
            row.readTable(wordWithLimitSubquery),
            [
              (
                row.readTable(_database.meanings),
                row.readTable(_database.references)
              )
            ]
          ));
        } else {
          condition.first.$2.add((
            row.readTable(_database.meanings),
            row.readTable(_database.references)
          ));
        }
      }
      return wordList;
    });
    return result;
  }

  @override
  Future<void> insert(WordsCompanion item) {
    // TODO: implement insert
    throw UnimplementedError();
  }

  @override
  Future<void> insertMany(List<WordsCompanion> list) {
    // TODO: implement insertMany
    throw UnimplementedError();
  }

  @override
  Future<void> update(WordsCompanion item) {
    // TODO: implement update
    throw UnimplementedError();
  }

  Future<int> count() async {
    final amountOfWords = _database.words.id.count();
    final query = _database.select(_database.words);

    final result = await query.addColumns([amountOfWords]).getSingle();
    final wordCount = result.read(amountOfWords);
    return wordCount ?? 0;
  }

//   final AppDatabase _database;

//   WordRepository(this._database);

//   @override
//   Future<void> insert(WordsCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<void> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<List<WordWithMeaning>> listByPage({int page = 1, int size = 50}) {
//     int offset = (page - 1) * size;
//     int limit = size;

//     final wordWithLimit = Subquery(
//       _database.select(_database.word)
//         ..orderBy([(row) => OrderingTerm.asc(row.word)])
//         ..limit(limit, offset: offset),
//       's',
//     );

//     final query = _database.select(wordWithLimit).join([
//       innerJoin(
//           _database.meaning,
//           wordWithLimit
//               .ref(_database.word.id)
//               .equalsExp(_database.meaning.wordId)),
//       innerJoin(_database.reference,
//           _database.meaning.referenceId.equalsExp(_database.reference.id))
//     ]);

//     return query.watch().map((rows) {
//       return rows.map((row) {
//         return (
//           row.readTable(wordWithLimit),
//           (row.readTable(_database.meaning), row.readTable(_database.reference))
//         );
//       }).toList();
//     });
//   }

//   @override
//   Future<void> update(WordCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<WordCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.word, list);
//     });
//   }
}

// class UserRepository extends Repository<User, UserCompanion> {
//   final AppDatabase _database;

//   UserRepository(this._database);

//   @override
//   Future<void> insert(UserCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<User> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<void> listByPage({int page = 1, int size = 50}) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> update(UserCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<UserCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.user, list);
//     });
//   }
// }

// class ReferenceRepository extends Repository<Reference, ReferenceCompanion> {
//   final AppDatabase _database;

//   ReferenceRepository(this._database);

//   @override
//   Future<void> insert(ReferenceCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<Reference> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<void> listByPage({int page = 1, int size = 50}) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> update(ReferenceCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<ReferenceCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.reference, list);
//     });
//   }
// }

// class MeaningRepository extends Repository<Meaning, MeaningCompanion> {
//   final AppDatabase _database;

//   MeaningRepository(this._database);

//   @override
//   Future<void> insert(MeaningCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Stream<Meaning> getById(int id) {
//     throw UnimplementedError();
//   }

//   Stream<void> listByPage({int page = 1, int size = 50}) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> update(MeaningCompanion item) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> delete(int id) {
//     throw UnimplementedError();
//   }

//   @override
//   Future<void> insertMany(List<MeaningCompanion> list) async {
//     await _database.batch((batch) {
//       batch.insertAll(_database.meaning, list);
//     });
//   }
// }
